<!DOCTYPE html>
<html>
  <head>
    <title>Flappy Bird Clone</title>
    <style>
        body {
            height: 80vh;
            margin: 0;
            overflow: hidden; /* Hide scrollbar */
        }

        canvas {
            border: 1px solid black;
            position: absolute;
            top: 30;
            bottom: 100;
            left: 0;
            right: 0;
            margin: auto;
        }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas" width="576" height="500"></canvas>
        <script>
            let canvas = document.getElementById("gameCanvas");
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            let ctx = canvas.getContext("2d");

            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });

        let gravity = 0.28;
        let birdMovement = 0;
        let gameActive = true;
        let score = 0;
        let highScore = 0;
        let canScore = true;
        let birdY = canvas.height / 2;

        let pipeList = [];
        let pipeHeight = [canvas.height * 0.6, canvas.height * 0.65, canvas.height * 0.7, canvas.height * 0.75, canvas.height * 0.8];

        let bgImage = new Image();
        bgImage.src = 'assets/background-day.png';

        let birdImage = new Image();
        birdImage.src = 'assets/latest(1).png';

        let pipeImage = new Image();
        pipeImage.src = 'assets/pipe-green.png';

        let gameOverImage = new Image();
        gameOverImage.src = 'assets/message-removebg-preview.png';

        function createPipe() {
            let gap = 212;
            let minPipeTop = 100;  // minimum space from the top
            let maxPipeTop = canvas.height - gap ;  // maximum space for top pipe, ensuring enough space for bottom pipe
            let randomY = Math.floor(Math.random() * (maxPipeTop - minPipeTop + 1) + minPipeTop);
        
            let bottomPipe = { x: canvas.width, y: randomY + gap, type: 'bottom' };
            let topPipe = { x: canvas.width, y: randomY, type: 'top' };
        
            return [bottomPipe, topPipe];
        }

        function movePipes(pipes) {
            for(let pipe of pipes) {
                pipe.x -= 5;
            }
            return pipes.filter(pipe => pipe.x > -pipeImage.width);
        }

        function drawPipes(pipes) {
            for (let pipe of pipes) {
                if (pipe.type === 'top') {
                    ctx.save();
                    ctx.translate(0, pipe.y); 
                    ctx.scale(1, -1); 
                    ctx.drawImage(pipeImage, pipe.x, 0, pipeImage.width *1.5, canvas.height);
                    ctx.restore();
                } else {
                    ctx.drawImage(pipeImage, pipe.x, pipe.y, pipeImage.width *1.5, canvas.height - pipe.y);
                }
            }
        }

        function checkCollision(pipes) {
            for(let pipe of pipes) {
            let birdBox = { x: 100, y: birdY, width: birdImage.width * 1.5, height: birdImage.height * 1.5 };

            let correctedY = (pipe.type === 'top') ? pipe.y - pipeImage.height * 1.5 : pipe.y;
            let pipeBox = { x: pipe.x, y: correctedY, width: pipeImage.width * 1.5, height: pipeImage.height * 1.5 };

            if (birdBox.x < pipeBox.x + pipeBox.width &&
                birdBox.x + birdBox.width > pipeBox.x &&
                birdBox.y < pipeBox.y + pipeBox.height &&
                birdBox.y + birdBox.height > pipeBox.y) {
                    return false;
            }
        }
        
        if (birdY <= 0 || birdY >= canvas.height - birdImage.height * 1.5) {
            return false;
        }
        return true;
            }
        
            function pipeScoreCheck() {
                for (let pipe of pipeList) {
        if (pipe.type === 'bottom' && 1 < pipe.x && pipe.x < 150 && canScore) {
            score++;
            canScore = false;
        }
        if (pipe.x < 0) {
            canScore = true;
        }
    }
    }
        
            function drawScore() {
                ctx.font = "40px Arial";
                ctx.fillStyle = "white";
                ctx.fillText("Score: " + score, 10, 50);
            }

            function resetGame() {
                pipeList = [];
                birdY = canvas.height / 2;
                birdMovement = 0;
                score = 0;
                canScore = true;
            }
            // Define the 'jump' function separately
            function jump(event) {
                if (event) event.preventDefault();  // Prevent additional events like 'click'
                
                if (gameActive) {
                    birdMovement = 0;
                    birdMovement -= 8.5;
                } else {
                    gameActive = true;
                    resetGame();
                }
            }

            // Reference the 'jump' function in the event listeners
            canvas.addEventListener('click', jump);
            canvas.addEventListener('touchstart', jump);
        
            function gameOver() {
                if (score > highScore) {
                    highScore = score;
        }
                ctx.font = "40px Arial";
                ctx.fillStyle = "white";

                // Resizing the game over image
                let gameOverWidth = canvas.width * 1.4; // 80% of canvas width
                let gameOverHeight = canvas.height * 1.4; // 80% of canvas height
                let xPosition = (canvas.width - gameOverWidth) / 2; // Center the x-position
                let yPosition = (canvas.height - gameOverHeight) / 2; // Center the y-position

                ctx.drawImage(gameOverImage, xPosition, yPosition, gameOverWidth, gameOverHeight);

                ctx.fillText("Current Score: " + score, 10, 50);
                ctx.fillText("High Score: " + highScore, 10, 100);
    }
        
            function gameLoop() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
        
                ctx.drawImage(bgImage, -100, 0, canvas.width + 200, canvas.height);
        
                if (gameActive) {
                    birdMovement += gravity;
                    birdY += birdMovement;
                    let birdWidth = birdImage.width * 1.5;  // Double the original width
                    let birdHeight = birdImage.height * 1.5;  // Double the original height
                    ctx.drawImage(birdImage, 100, birdY, birdWidth, birdHeight);  // Modified dimensions
        
                    pipeList = movePipes(pipeList);
                    drawPipes(pipeList);
        
                    gameActive = checkCollision(pipeList);
                    pipeScoreCheck();
                    drawScore();
                } else {
                    gameOver();  // Call the gameOver function here
                    // Draw game over image
                    
                    
                    // Current Score and High Score moved to top left
                    ctx.font = "40px Arial";
                    ctx.fillStyle = "white";
                    ctx.fillText("Current Score: " + score, 10, 50);
                    ctx.fillText("High Score: " + highScore, 10, 100);
                }
                
        
                requestAnimationFrame(gameLoop);
            }
        
            setInterval(() => {
                if (gameActive) {
                    pipeList.push(...createPipe());
                }
            }, 1200);
        
            document.addEventListener('keydown', function(event) {
                if (event.code === 'Space') {
                    if (gameActive) {
                        birdMovement = 0;
                        birdMovement -= 9.2;
                    } else {
                        gameActive = true;
                        resetGame();
                    }
                }
            });
        
            gameLoop();
        </script>
  </body>
</html>